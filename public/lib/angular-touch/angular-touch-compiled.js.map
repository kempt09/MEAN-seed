{"version":3,"sources":["angular-touch.js"],"names":[],"mappings":"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","file":"angular-touch-compiled.js","sourcesContent":["/**\n * @license AngularJS v1.5.0\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* global ngTouchClickDirectiveFactory: false,\n */\n\n/**\n * @ngdoc module\n * @name ngTouch\n * @description\n *\n * # ngTouch\n *\n * The `ngTouch` module provides touch events and other helpers for touch-enabled devices.\n * The implementation is based on jQuery Mobile touch event handling\n * ([jquerymobile.com](http://jquerymobile.com/)).\n *\n *\n * See {@link ngTouch.$swipe `$swipe`} for usage.\n *\n * <div doc-module-components=\"ngTouch\"></div>\n *\n */\n\n// define ngTouch module\n/* global -ngTouch */\nvar ngTouch = angular.module('ngTouch', []);\n\nngTouch.provider('$touch', $TouchProvider);\n\nfunction nodeName_(element) {\n  return angular.lowercase(element.nodeName || (element[0] && element[0].nodeName));\n}\n\n/**\n * @ngdoc provider\n * @name $touchProvider\n *\n * @description\n * The `$touchProvider` allows enabling / disabling {@link ngTouch.ngClick ngTouch's ngClick directive}.\n */\n$TouchProvider.$inject = ['$provide', '$compileProvider'];\nfunction $TouchProvider($provide, $compileProvider) {\n\n  /**\n   * @ngdoc method\n   * @name  $touchProvider#ngClickOverrideEnabled\n   *\n   * @param {boolean=} enabled update the ngClickOverrideEnabled state if provided, otherwise just return the\n   * current ngClickOverrideEnabled state\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   *\n   * @kind function\n   *\n   * @description\n   * Call this method to enable/disable {@link ngTouch.ngClick ngTouch's ngClick directive}. If enabled,\n   * the default ngClick directive will be replaced by a version that eliminates the 300ms delay for\n   * click events on browser for touch-devices.\n   *\n   * The default is `false`.\n   *\n   */\n  var ngClickOverrideEnabled = false;\n  var ngClickDirectiveAdded = false;\n  this.ngClickOverrideEnabled = function(enabled) {\n    if (angular.isDefined(enabled)) {\n\n      if (enabled && !ngClickDirectiveAdded) {\n        ngClickDirectiveAdded = true;\n\n        // Use this to identify the correct directive in the delegate\n        ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';\n        $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);\n\n        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\n          if (ngClickOverrideEnabled) {\n            // drop the default ngClick directive\n            $delegate.shift();\n          } else {\n            // drop the ngTouch ngClick directive if the override has been re-disabled (because\n            // we cannot de-register added directives)\n            var i = $delegate.length - 1;\n            while (i >= 0) {\n              if ($delegate[i].$$moduleName === 'ngTouch') {\n                $delegate.splice(i, 1);\n                break;\n              }\n              i--;\n            }\n          }\n\n          return $delegate;\n        }]);\n      }\n\n      ngClickOverrideEnabled = enabled;\n      return this;\n    }\n\n    return ngClickOverrideEnabled;\n  };\n\n  /**\n  * @ngdoc service\n  * @name $touch\n  * @kind object\n  *\n  * @description\n  * Provides the {@link ngTouch.$touch#ngClickOverrideEnabled `ngClickOverrideEnabled`} method.\n  *\n  */\n  this.$get = function() {\n    return {\n      /**\n       * @ngdoc method\n       * @name  $touch#ngClickOverrideEnabled\n       *\n       * @returns {*} current value of `ngClickOverrideEnabled` set in the {@link ngTouch.$touchProvider $touchProvider},\n       * i.e. if {@link ngTouch.ngClick ngTouch's ngClick} directive is enabled.\n       *\n       * @kind function\n       */\n      ngClickOverrideEnabled: function() {\n        return ngClickOverrideEnabled;\n      }\n    };\n  };\n\n}\n\n/* global ngTouch: false */\n\n    /**\n     * @ngdoc service\n     * @name $swipe\n     *\n     * @description\n     * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe\n     * behavior, to make implementing swipe-related directives more convenient.\n     *\n     * Requires the {@link ngTouch `ngTouch`} module to be installed.\n     *\n     * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`.\n     *\n     * # Usage\n     * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element\n     * which is to be watched for swipes, and an object with four handler functions. See the\n     * documentation for `bind` below.\n     */\n\nngTouch.factory('$swipe', [function() {\n  // The total distance in any direction before we make the call on swipe vs. scroll.\n  var MOVE_BUFFER_RADIUS = 10;\n\n  var POINTER_EVENTS = {\n    'mouse': {\n      start: 'mousedown',\n      move: 'mousemove',\n      end: 'mouseup'\n    },\n    'touch': {\n      start: 'touchstart',\n      move: 'touchmove',\n      end: 'touchend',\n      cancel: 'touchcancel'\n    }\n  };\n\n  function getCoordinates(event) {\n    var originalEvent = event.originalEvent || event;\n    var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n    var e = (originalEvent.changedTouches && originalEvent.changedTouches[0]) || touches[0];\n\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n\n  function getEvents(pointerTypes, eventType) {\n    var res = [];\n    angular.forEach(pointerTypes, function(pointerType) {\n      var eventName = POINTER_EVENTS[pointerType][eventType];\n      if (eventName) {\n        res.push(eventName);\n      }\n    });\n    return res.join(' ');\n  }\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $swipe#bind\n     *\n     * @description\n     * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an\n     * object containing event handlers.\n     * The pointer types that should be used can be specified via the optional\n     * third argument, which is an array of strings `'mouse'` and `'touch'`. By default,\n     * `$swipe` will listen for `mouse` and `touch` events.\n     *\n     * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`\n     * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }` and the raw\n     * `event`. `cancel` receives the raw `event` as its single parameter.\n     *\n     * `start` is called on either `mousedown` or `touchstart`. After this event, `$swipe` is\n     * watching for `touchmove` or `mousemove` events. These events are ignored until the total\n     * distance moved in either dimension exceeds a small threshold.\n     *\n     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.\n     * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.\n     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.\n     *   A `cancel` event is sent.\n     *\n     * `move` is called on `mousemove` and `touchmove` after the above logic has determined that\n     * a swipe is in progress.\n     *\n     * `end` is called when a swipe is successfully completed with a `touchend` or `mouseup`.\n     *\n     * `cancel` is called either on a `touchcancel` from the browser, or when we begin scrolling\n     * as described above.\n     *\n     */\n    bind: function(element, eventHandlers, pointerTypes) {\n      // Absolute total movement, used to control swipe vs. scroll.\n      var totalX, totalY;\n      // Coordinates of the start position.\n      var startCoords;\n      // Last event's position.\n      var lastPos;\n      // Whether a swipe is active.\n      var active = false;\n\n      pointerTypes = pointerTypes || ['mouse', 'touch'];\n      element.on(getEvents(pointerTypes, 'start'), function(event) {\n        startCoords = getCoordinates(event);\n        active = true;\n        totalX = 0;\n        totalY = 0;\n        lastPos = startCoords;\n        eventHandlers['start'] && eventHandlers['start'](startCoords, event);\n      });\n      var events = getEvents(pointerTypes, 'cancel');\n      if (events) {\n        element.on(events, function(event) {\n          active = false;\n          eventHandlers['cancel'] && eventHandlers['cancel'](event);\n        });\n      }\n\n      element.on(getEvents(pointerTypes, 'move'), function(event) {\n        if (!active) return;\n\n        // Android will send a touchcancel if it thinks we're starting to scroll.\n        // So when the total distance (+ or - or both) exceeds 10px in either direction,\n        // we either:\n        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.\n        // - On totalY > totalX, we let the browser handle it as a scroll.\n\n        if (!startCoords) return;\n        var coords = getCoordinates(event);\n\n        totalX += Math.abs(coords.x - lastPos.x);\n        totalY += Math.abs(coords.y - lastPos.y);\n\n        lastPos = coords;\n\n        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {\n          return;\n        }\n\n        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.\n        if (totalY > totalX) {\n          // Allow native scrolling to take over.\n          active = false;\n          eventHandlers['cancel'] && eventHandlers['cancel'](event);\n          return;\n        } else {\n          // Prevent the browser from scrolling.\n          event.preventDefault();\n          eventHandlers['move'] && eventHandlers['move'](coords, event);\n        }\n      });\n\n      element.on(getEvents(pointerTypes, 'end'), function(event) {\n        if (!active) return;\n        active = false;\n        eventHandlers['end'] && eventHandlers['end'](getCoordinates(event), event);\n      });\n    }\n  };\n}]);\n\n/* global ngTouch: false,\n  nodeName_: false\n*/\n\n/**\n * @ngdoc directive\n * @name ngClick\n * @deprecated\n *\n * @description\n * <div class=\"alert alert-danger\">\n * **DEPRECATION NOTICE**: Beginning with Angular 1.5, this directive is deprecated and by default **disabled**.\n * The directive will receive no further support and might be removed from future releases.\n * If you need the directive, you can enable it with the {@link ngTouch.$touchProvider $touchProvider#ngClickOverrideEnabled}\n * function. We also recommend that you migrate to [FastClick](https://github.com/ftlabs/fastclick).\n * To learn more about the 300ms delay, this [Telerik article](http://developer.telerik.com/featured/300-ms-click-delay-ios-8/)\n * gives a good overview.\n * </div>\n * A more powerful replacement for the default ngClick designed to be used on touchscreen\n * devices. Most mobile browsers wait about 300ms after a tap-and-release before sending\n * the click event. This version handles them immediately, and then prevents the\n * following click event from propagating.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * This directive can fall back to using an ordinary click event, and so works on desktop\n * browsers as well as mobile.\n *\n * This directive also sets the CSS class `ng-click-active` while the element is being held\n * down (by a mouse click or touch) so you can restyle the depressed element if you wish.\n *\n * @element ANY\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate\n * upon tap. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngClickExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\n          Increment\n        </button>\n        count: {{ count }}\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngClickExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nvar ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement',\n    function($parse, $timeout, $rootElement) {\n  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.\n  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.\n  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click\n  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.\n\n  var ACTIVE_CLASS_NAME = 'ng-click-active';\n  var lastPreventedTime;\n  var touchCoordinates;\n  var lastLabelClickCoordinates;\n\n\n  // TAP EVENTS AND GHOST CLICKS\n  //\n  // Why tap events?\n  // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you're\n  // double-tapping, and then fire a click event.\n  //\n  // This delay sucks and makes mobile apps feel unresponsive.\n  // So we detect touchstart, touchcancel and touchend ourselves and determine when\n  // the user has tapped on something.\n  //\n  // What happens when the browser then generates a click event?\n  // The browser, of course, also detects the tap and fires a click after a delay. This results in\n  // tapping/clicking twice. We do \"clickbusting\" to prevent it.\n  //\n  // How does it work?\n  // We attach global touchstart and click handlers, that run during the capture (early) phase.\n  // So the sequence for a tap is:\n  // - global touchstart: Sets an \"allowable region\" at the point touched.\n  // - element's touchstart: Starts a touch\n  // (- touchcancel ends the touch, no click follows)\n  // - element's touchend: Determines if the tap is valid (didn't move too far away, didn't hold\n  //   too long) and fires the user's tap handler. The touchend also calls preventGhostClick().\n  // - preventGhostClick() removes the allowable region the global touchstart created.\n  // - The browser generates a click event.\n  // - The global click handler catches the click, and checks whether it was in an allowable region.\n  //     - If preventGhostClick was called, the region will have been removed, the click is busted.\n  //     - If the region is still there, the click proceeds normally. Therefore clicks on links and\n  //       other elements without ngTap on them work normally.\n  //\n  // This is an ugly, terrible hack!\n  // Yeah, tell me about it. The alternatives are using the slow click events, or making our users\n  // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular\n  // encapsulates this ugly logic away from the user.\n  //\n  // Why not just put click handlers on the element?\n  // We do that too, just to be sure. If the tap event caused the DOM to change,\n  // it is possible another element is now in that position. To take account for these possibly\n  // distinct elements, the handlers are global and care only about coordinates.\n\n  // Checks if the coordinates are close enough to be within the region.\n  function hit(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;\n  }\n\n  // Checks a list of allowable regions against a click location.\n  // Returns true if the click should be allowed.\n  // Splices out the allowable region from the list after it has been used.\n  function checkAllowableRegions(touchCoordinates, x, y) {\n    for (var i = 0; i < touchCoordinates.length; i += 2) {\n      if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {\n        touchCoordinates.splice(i, i + 2);\n        return true; // allowable region\n      }\n    }\n    return false; // No allowable region; bust it.\n  }\n\n  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick\n  // was called recently.\n  function onClick(event) {\n    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {\n      return; // Too old.\n    }\n\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label\n    // and on the input element). Depending on the exact browser, this second click we don't want\n    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label\n    // click event\n    if (x < 1 && y < 1) {\n      return; // offscreen\n    }\n    if (lastLabelClickCoordinates &&\n        lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {\n      return; // input click triggered by label click\n    }\n    // reset label click coordinates on first subsequent click\n    if (lastLabelClickCoordinates) {\n      lastLabelClickCoordinates = null;\n    }\n    // remember label click coordinates to prevent click busting of trigger click event on input\n    if (nodeName_(event.target) === 'label') {\n      lastLabelClickCoordinates = [x, y];\n    }\n\n    // Look for an allowable region containing this click.\n    // If we find one, that means it was created by touchstart and not removed by\n    // preventGhostClick, so we don't bust it.\n    if (checkAllowableRegions(touchCoordinates, x, y)) {\n      return;\n    }\n\n    // If we didn't find an allowable region, bust the click.\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Blur focused form elements\n    event.target && event.target.blur && event.target.blur();\n  }\n\n\n  // Global touchstart handler that creates an allowable region for a click event.\n  // This allowable region can be removed by preventGhostClick if we want to bust it.\n  function onTouchStart(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    touchCoordinates.push(x, y);\n\n    $timeout(function() {\n      // Remove the allowable region.\n      for (var i = 0; i < touchCoordinates.length; i += 2) {\n        if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {\n          touchCoordinates.splice(i, i + 2);\n          return;\n        }\n      }\n    }, PREVENT_DURATION, false);\n  }\n\n  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a\n  // zone around the touchstart where clicks will get busted.\n  function preventGhostClick(x, y) {\n    if (!touchCoordinates) {\n      $rootElement[0].addEventListener('click', onClick, true);\n      $rootElement[0].addEventListener('touchstart', onTouchStart, true);\n      touchCoordinates = [];\n    }\n\n    lastPreventedTime = Date.now();\n\n    checkAllowableRegions(touchCoordinates, x, y);\n  }\n\n  // Actual linking function.\n  return function(scope, element, attr) {\n    var clickHandler = $parse(attr.ngClick),\n        tapping = false,\n        tapElement,  // Used to blur the element after a tap.\n        startTime,   // Used to check if the tap was held too long.\n        touchStartX,\n        touchStartY;\n\n    function resetState() {\n      tapping = false;\n      element.removeClass(ACTIVE_CLASS_NAME);\n    }\n\n    element.on('touchstart', function(event) {\n      tapping = true;\n      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.\n      // Hack for Safari, which can target text nodes instead of containers.\n      if (tapElement.nodeType == 3) {\n        tapElement = tapElement.parentNode;\n      }\n\n      element.addClass(ACTIVE_CLASS_NAME);\n\n      startTime = Date.now();\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n      var e = touches[0];\n      touchStartX = e.clientX;\n      touchStartY = e.clientY;\n    });\n\n    element.on('touchcancel', function(event) {\n      resetState();\n    });\n\n    element.on('touchend', function(event) {\n      var diff = Date.now() - startTime;\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = (originalEvent.changedTouches && originalEvent.changedTouches.length) ?\n          originalEvent.changedTouches :\n          ((originalEvent.touches && originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);\n      var e = touches[0];\n      var x = e.clientX;\n      var y = e.clientY;\n      var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));\n\n      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {\n        // Call preventGhostClick so the clickbuster will catch the corresponding click.\n        preventGhostClick(x, y);\n\n        // Blur the focused element (the button, probably) before firing the callback.\n        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.\n        // I couldn't get anything to work reliably on Android Chrome.\n        if (tapElement) {\n          tapElement.blur();\n        }\n\n        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {\n          element.triggerHandler('click', [event]);\n        }\n      }\n\n      resetState();\n    });\n\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n    // something else nearby.\n    element.onclick = function(event) { };\n\n    // Actual click handler.\n    // There are three different kinds of clicks, only two of which reach this point.\n    // - On desktop browsers without touch events, their clicks will always come here.\n    // - On mobile browsers, the simulated \"fast\" click will call this.\n    // - But the browser's follow-up slow click will be \"busted\" before it reaches this handler.\n    // Therefore it's safe to use this directive on both mobile and desktop.\n    element.on('click', function(event, touchend) {\n      scope.$apply(function() {\n        clickHandler(scope, {$event: (touchend || event)});\n      });\n    });\n\n    element.on('mousedown', function(event) {\n      element.addClass(ACTIVE_CLASS_NAME);\n    });\n\n    element.on('mousemove mouseup', function(event) {\n      element.removeClass(ACTIVE_CLASS_NAME);\n    });\n\n  };\n}];\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc directive\n * @name ngSwipeLeft\n *\n * @description\n * Specify custom behavior when an element is swiped to the left on a touchscreen device.\n * A leftward swipe is a quick, right-to-left slide of the finger.\n * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * To disable the mouse click and drag functionality, add `ng-swipe-disable-mouse` to\n * the `ng-swipe-left` or `ng-swipe-right` DOM Element.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate\n * upon left swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeLeftExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeLeftExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\n/**\n * @ngdoc directive\n * @name ngSwipeRight\n *\n * @description\n * Specify custom behavior when an element is swiped to the right on a touchscreen device.\n * A rightward swipe is a quick, left-to-right slide of the finger.\n * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate\n * upon right swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeRightExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeRightExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nfunction makeSwipeDirective(directiveName, direction, eventName) {\n  ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {\n    // The maximum vertical delta for a swipe should be less than 75px.\n    var MAX_VERTICAL_DISTANCE = 75;\n    // Vertical distance should not be more than a fraction of the horizontal distance.\n    var MAX_VERTICAL_RATIO = 0.3;\n    // At least a 30px lateral motion is necessary for a swipe.\n    var MIN_HORIZONTAL_DISTANCE = 30;\n\n    return function(scope, element, attr) {\n      var swipeHandler = $parse(attr[directiveName]);\n\n      var startCoords, valid;\n\n      function validSwipe(coords) {\n        // Check that it's within the coordinates.\n        // Absolute vertical distance must be within tolerances.\n        // Horizontal distance, we take the current X - the starting X.\n        // This is negative for leftward swipes and positive for rightward swipes.\n        // After multiplying by the direction (-1 for left, +1 for right), legal swipes\n        // (ie. same direction as the directive wants) will have a positive delta and\n        // illegal ones a negative delta.\n        // Therefore this delta must be positive, and larger than the minimum.\n        if (!startCoords) return false;\n        var deltaY = Math.abs(coords.y - startCoords.y);\n        var deltaX = (coords.x - startCoords.x) * direction;\n        return valid && // Short circuit for already-invalidated swipes.\n            deltaY < MAX_VERTICAL_DISTANCE &&\n            deltaX > 0 &&\n            deltaX > MIN_HORIZONTAL_DISTANCE &&\n            deltaY / deltaX < MAX_VERTICAL_RATIO;\n      }\n\n      var pointerTypes = ['touch'];\n      if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {\n        pointerTypes.push('mouse');\n      }\n      $swipe.bind(element, {\n        'start': function(coords, event) {\n          startCoords = coords;\n          valid = true;\n        },\n        'cancel': function(event) {\n          valid = false;\n        },\n        'end': function(coords, event) {\n          if (validSwipe(coords)) {\n            scope.$apply(function() {\n              element.triggerHandler(eventName);\n              swipeHandler(scope, {$event: event});\n            });\n          }\n        }\n      }, pointerTypes);\n    };\n  }]);\n}\n\n// Left is negative X-coordinate, right is positive.\nmakeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');\nmakeSwipeDirective('ngSwipeRight', 1, 'swiperight');\n\n\n\n})(window, window.angular);\n"]}